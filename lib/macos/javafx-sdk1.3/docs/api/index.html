
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="./general.css" rel="stylesheet">
<link href="./sdk.css" rel="stylesheet">
<script type="text/javascript" src="./mootools-1.2.1-yui.js"></script><script type="text/javascript" src="./sessvars.js"></script><script type="text/javascript" src="./sdk.js"></script>
<meta name="collection" content="api">
<meta name="keywords" content="JavaFX, Java FX">
<title>JavaFX 1.3.1 API |  Overview  | Java FX</title>
</head>
<body>
<div id="top-header">
<h1>
<a href="./index.html">Java<b>FX</b>: <i>Bringing Rich Experiences To All the Screens Of Your Life</i></a>
</h1>
<h3 id="master-index-link">
<a href="./master-index.html">master index</a>
</h3>
<h3 id="collapse-expand-switcher">
<a href="#" id="collapse-expand-link">expand all</a>
</h3>
<h3 id="profile-switcher">Profile: <a href="#" id="select-desktop-profile">desktop</a>, <a href="#" id="select-common-profile">common</a>
</h3>
</div>
<ul id="classes-toc">
<li>
<h4 class="header">
<a href="#">com.javafx.preview.control</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.CheckMenuItem.html">CheckMenuItem</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.CustomMenuItem.html">CustomMenuItem</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.Menu.html">Menu</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.MenuBar.html">MenuBar</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.MenuButton.html">MenuButton</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.MenuItem.html">MenuItem</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.MenuItemBase.html">MenuItemBase</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.PopupMenu.html">PopupMenu</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.RadioMenuItem.html">RadioMenuItem</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.SplitMenuButton.html">SplitMenuButton</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.ToolBar.html">ToolBar</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.TreeCell.html">TreeCell</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.TreeItem.html">TreeItem</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.TreeItemBase.html">TreeItemBase</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.control/com.javafx.preview.control.TreeView.html">TreeView</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">com.javafx.preview.layout</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="com.javafx.preview.layout/com.javafx.preview.layout.Grid.html">Grid</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.layout/com.javafx.preview.layout.GridLayoutInfo.html">GridLayoutInfo</a>
</li>
<li class="profile-common ">
<a href="com.javafx.preview.layout/com.javafx.preview.layout.GridRow.html">GridRow</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.animation</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.Interpolatable.html">Interpolatable</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.Interpolator.html">Interpolator</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.KeyFrame.html">KeyFrame</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.KeyValue.html">KeyValue</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.KeyValueTarget.html">KeyValueTarget</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.KeyValueTarget.Type.html">KeyValueTarget.Type</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.SimpleInterpolator.html">SimpleInterpolator</a>
</li>
<li class="profile-common ">
<a href="javafx.animation/javafx.animation.Timeline.html">Timeline</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.animation.transition</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.AnimationPath.html">AnimationPath</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.FadeTransition.html">FadeTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.OrientationType.html">OrientationType</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.ParallelTransition.html">ParallelTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.PathTransition.html">PathTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.PauseTransition.html">PauseTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.RotateTransition.html">RotateTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.ScaleTransition.html">ScaleTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.SequentialTransition.html">SequentialTransition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.Transition.html">Transition</a>
</li>
<li class="profile-common ">
<a href="javafx.animation.transition/javafx.animation.transition.TranslateTransition.html">TranslateTransition</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.async</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.async/javafx.async.JavaTaskBase.html">JavaTaskBase</a>
</li>
<li class="profile-common ">
<a href="javafx.async/javafx.async.RunnableFuture.html">RunnableFuture</a>
</li>
<li class="profile-common ">
<a href="javafx.async/javafx.async.Task.html">Task</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data</a>
</h4>
<ul class="content">
<li class="">
<a href="javafx.data/javafx.data.Converter.html">Converter</a>
</li>
<li class="profile-common ">
<a href="javafx.data/javafx.data.Pair.html">Pair</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data.feed</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.data.feed/javafx.data.feed.Base.html">Base</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed/javafx.data.feed.FeedTask.html">FeedTask</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data.feed.atom</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Atom.html">Atom</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.AtomTask.html">AtomTask</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Category.html">Category</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Content.html">Content</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Date.html">Date</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Entry.html">Entry</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Factory.html">Factory</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Feed.html">Feed</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Generator.html">Generator</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Id.html">Id</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Link.html">Link</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.atom/javafx.data.feed.atom.Person.html">Person</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data.feed.rss</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Category.html">Category</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Channel.html">Channel</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Enclosure.html">Enclosure</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Factory.html">Factory</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Guid.html">Guid</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Image.html">Image</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Item.html">Item</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.RSS.html">RSS</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.RssTask.html">RssTask</a>
</li>
<li class="profile-common ">
<a href="javafx.data.feed.rss/javafx.data.feed.rss.Source.html">Source</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data.pull</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.data.pull/javafx.data.pull.Event.html">Event</a>
</li>
<li class="">
<a href="javafx.data.pull/javafx.data.pull.ParserTask.html">ParserTask</a>
</li>
<li class="profile-common ">
<a href="javafx.data.pull/javafx.data.pull.PullParser.html">PullParser</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.data.xml</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.data.xml/javafx.data.xml.QName.html">QName</a>
</li>
<li class="">
<a href="javafx.data.xml/javafx.data.xml.XMLConstants.html">XMLConstants</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.date</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.date/javafx.date.DateTime.html">DateTime</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.ext.swing</a>
</h4>
<ul class="content">
<li class="private">
<a href="javafx.ext.swing/javafx.ext.swing.JTextFieldImpl.html">JTextFieldImpl</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingAbstractButton.html">SwingAbstractButton</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingButton.html">SwingButton</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingCheckBox.html">SwingCheckBox</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingComboBox.html">SwingComboBox</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingComboBoxItem.html">SwingComboBoxItem</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingComponent.html">SwingComponent</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingHorizontalAlignment.html">SwingHorizontalAlignment</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingIcon.html">SwingIcon</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingLabel.html">SwingLabel</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingList.html">SwingList</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingListItem.html">SwingListItem</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingRadioButton.html">SwingRadioButton</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingScrollPane.html">SwingScrollPane</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingScrollableComponent.html">SwingScrollableComponent</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingSlider.html">SwingSlider</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingTextField.html">SwingTextField</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingToggleButton.html">SwingToggleButton</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingToggleGroup.html">SwingToggleGroup</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingUtils.html">SwingUtils</a>
</li>
<li class="profile-desktop conditional swing ">
<a href="javafx.ext.swing/javafx.ext.swing.SwingVerticalAlignment.html">SwingVerticalAlignment</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.fxd</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.fxd/javafx.fxd.Duplicator.html">Duplicator</a>
</li>
<li class="profile-common ">
<a href="javafx.fxd/javafx.fxd.FXDContent.html">FXDContent</a>
</li>
<li class="profile-common ">
<a href="javafx.fxd/javafx.fxd.FXDLoader.html">FXDLoader</a>
</li>
<li class="profile-common ">
<a href="javafx.fxd/javafx.fxd.FXDNode.html">FXDNode</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.geometry</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.BoundingBox.html">BoundingBox</a>
</li>
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.Bounds.html">Bounds</a>
</li>
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.Dimension2D.html">Dimension2D</a>
</li>
<li class="">
<a href="javafx.geometry/javafx.geometry.HPos.html">HPos</a>
</li>
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.Insets.html">Insets</a>
</li>
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.Point2D.html">Point2D</a>
</li>
<li class="profile-common conditional scene3d ">
<a href="javafx.geometry/javafx.geometry.Point3D.html">Point3D</a>
</li>
<li class="profile-common ">
<a href="javafx.geometry/javafx.geometry.Rectangle2D.html">Rectangle2D</a>
</li>
<li class="">
<a href="javafx.geometry/javafx.geometry.VPos.html">VPos</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.io</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.io/javafx.io.Resource.html">Resource</a>
</li>
<li class="profile-common ">
<a href="javafx.io/javafx.io.Storage.html">Storage</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.io.http</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.io.http/javafx.io.http.HttpHeader.html">HttpHeader</a>
</li>
<li class="profile-common ">
<a href="javafx.io.http/javafx.io.http.HttpRequest.html">HttpRequest</a>
</li>
<li class="">
<a href="javafx.io.http/javafx.io.http.HttpStatus.html">HttpStatus</a>
</li>
<li class="profile-common ">
<a href="javafx.io.http/javafx.io.http.URLConverter.html">URLConverter</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.lang</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.lang/javafx.lang.Builtins.html">Builtins</a>
</li>
<li class="profile-common ">
<a href="javafx.lang/javafx.lang.Duration.html">Duration</a>
</li>
<li class="profile-common ">
<a href="javafx.lang/javafx.lang.FX.html">FX</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.reflect</a>
</h4>
<ul class="content">
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXBooleanValue.html">FXBooleanValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXChangeListener.html">FXChangeListener</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXChangeListenerID.html">FXChangeListenerID</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXClassType.html">FXClassType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXContext.html">FXContext</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXDoubleValue.html">FXDoubleValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXFloatValue.html">FXFloatValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXFunctionMember.html">FXFunctionMember</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXFunctionType.html">FXFunctionType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXFunctionValue.html">FXFunctionValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXIntegerValue.html">FXIntegerValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXJavaArrayType.html">FXJavaArrayType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.html">FXLocal</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.ClassType.html">FXLocal.ClassType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.Context.html">FXLocal.Context</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.FunctionValue.html">FXLocal.FunctionValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.ObjectValue.html">FXLocal.ObjectValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.Value.html">FXLocal.Value</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocal.VarMemberLocation.html">FXLocal.VarMemberLocation</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLocation.html">FXLocation</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXLongValue.html">FXLongValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXMember.html">FXMember</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXMemberFilter.html">FXMemberFilter</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXObjectValue.html">FXObjectValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXPrimitiveType.html">FXPrimitiveType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXPrimitiveValue.html">FXPrimitiveValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXSequenceBuilder.html">FXSequenceBuilder</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXSequenceType.html">FXSequenceType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXSequenceValue.html">FXSequenceValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXType.html">FXType</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXValue.html">FXValue</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXVarMember.html">FXVarMember</a>
</li>
<li class="profile-desktop ">
<a href="javafx.reflect/javafx.reflect.FXVarMemberLocation.html">FXVarMemberLocation</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.runtime</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.runtime/javafx.runtime.ConditionalFeature.html">ConditionalFeature</a>
</li>
<li class="profile-common ">
<a href="javafx.runtime/javafx.runtime.Platform.html">Platform</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.CacheHint.html">CacheHint</a>
</li>
<li class="profile-common conditional scene3d ">
<a href="javafx.scene/javafx.scene.Camera.html">Camera</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.Cursor.html">Cursor</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.CustomNode.html">CustomNode</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.Group.html">Group</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.ImageCursor.html">ImageCursor</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.Node.html">Node</a>
</li>
<li class="profile-common conditional scene3d ">
<a href="javafx.scene/javafx.scene.ParallelCamera.html">ParallelCamera</a>
</li>
<li class="">
<a href="javafx.scene/javafx.scene.Parent.html">Parent</a>
</li>
<li class="profile-common conditional scene3d ">
<a href="javafx.scene/javafx.scene.PerspectiveCamera.html">PerspectiveCamera</a>
</li>
<li class="profile-common ">
<a href="javafx.scene/javafx.scene.Scene.html">Scene</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.chart</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.AreaChart.html">AreaChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.AreaChart.Data.html">AreaChart.Data</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.AreaChart.Series.html">AreaChart.Series</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.BarChart.html">BarChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.BarChart.Data.html">BarChart.Data</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.BarChart.Series.html">BarChart.Series</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.BarChart3D.html">BarChart3D</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.BubbleChart.html">BubbleChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.BubbleChart.Data.html">BubbleChart.Data</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.BubbleChart.Series.html">BubbleChart.Series</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.Chart.html">Chart</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.LineChart.html">LineChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.LineChart.Data.html">LineChart.Data</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.LineChart.Series.html">LineChart.Series</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.PieChart.html">PieChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.PieChart.Data.html">PieChart.Data</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.PieChart3D.html">PieChart3D</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.ScatterChart.html">ScatterChart</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.ScatterChart.Data.html">ScatterChart.Data</a>
</li>
<li class="">
<a href="javafx.scene.chart/javafx.scene.chart.ScatterChart.Series.html">ScatterChart.Series</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart/javafx.scene.chart.XYChart.html">XYChart</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.chart.data</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.chart.data/javafx.scene.chart.data.Data.html">Data</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.data/javafx.scene.chart.data.Series.html">Series</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.chart.part</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.Axis.html">Axis</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.Axis.TickMark.html">Axis.TickMark</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.CategoryAxis.html">CategoryAxis</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.Legend.html">Legend</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.Legend.LegendItem.html">Legend.LegendItem</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.NumberAxis.html">NumberAxis</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.html">PlotSymbol</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.Circle.html">PlotSymbol.Circle</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.Cross.html">PlotSymbol.Cross</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.HollowDiamond.html">PlotSymbol.HollowDiamond</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.HollowTriangle.html">PlotSymbol.HollowTriangle</a>
</li>
<li class="">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.PlotSymbol.Square.html">PlotSymbol.Square</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.Side.html">Side</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.chart.part/javafx.scene.chart.part.ValueAxis.html">ValueAxis</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.control</a>
</h4>
<ul class="content">
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Behavior.html">Behavior</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Button.html">Button</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ButtonBase.html">ButtonBase</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.Cell.html">Cell</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.CheckBox.html">CheckBox</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.ChoiceBox.html">ChoiceBox</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.Control.html">Control</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Hyperlink.html">Hyperlink</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.IndexedCell.html">IndexedCell</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Keystroke.html">Keystroke</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Label.html">Label</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Labeled.html">Labeled</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.ListCell.html">ListCell</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.ListView.html">ListView</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.OverrunStyle.html">OverrunStyle</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.PasswordBox.html">PasswordBox</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ProgressBar.html">ProgressBar</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ProgressIndicator.html">ProgressIndicator</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.RadioButton.html">RadioButton</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ScrollBar.html">ScrollBar</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.ScrollBarPolicy.html">ScrollBarPolicy</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.ScrollView.html">ScrollView</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.Separator.html">Separator</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.Skin.html">Skin</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Slider.html">Slider</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.control/javafx.scene.control.TextBox.html">TextBox</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.TextInputControl.html">TextInputControl</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Toggle.html">Toggle</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ToggleButton.html">ToggleButton</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.ToggleGroup.html">ToggleGroup</a>
</li>
<li class="">
<a href="javafx.scene.control/javafx.scene.control.Tooltip.html">Tooltip</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.effect</a>
</h4>
<ul class="content">
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Blend.html">Blend</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.BlendMode.html">BlendMode</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Bloom.html">Bloom</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.BlurType.html">BlurType</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.BoxBlur.html">BoxBlur</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.ColorAdjust.html">ColorAdjust</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.DisplacementMap.html">DisplacementMap</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.DropShadow.html">DropShadow</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Effect.html">Effect</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.FloatMap.html">FloatMap</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Flood.html">Flood</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.GaussianBlur.html">GaussianBlur</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Glow.html">Glow</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Identity.html">Identity</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.InnerShadow.html">InnerShadow</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.InvertMask.html">InvertMask</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Lighting.html">Lighting</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.MotionBlur.html">MotionBlur</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.PerspectiveTransform.html">PerspectiveTransform</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Reflection.html">Reflection</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.SepiaTone.html">SepiaTone</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect/javafx.scene.effect.Shadow.html">Shadow</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.effect.light</a>
</h4>
<ul class="content">
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect.light/javafx.scene.effect.light.DistantLight.html">DistantLight</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect.light/javafx.scene.effect.light.Light.html">Light</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect.light/javafx.scene.effect.light.PointLight.html">PointLight</a>
</li>
<li class="profile-common conditional effect ">
<a href="javafx.scene.effect.light/javafx.scene.effect.light.SpotLight.html">SpotLight</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.image</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.image/javafx.scene.image.Image.html">Image</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.image/javafx.scene.image.ImageView.html">ImageView</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.input</a>
</h4>
<ul class="content">
<li class="profile-common conditional input_method ">
<a href="javafx.scene.input/javafx.scene.input.InputMethodEvent.html">InputMethodEvent</a>
</li>
<li class="profile-common conditional input_method ">
<a href="javafx.scene.input/javafx.scene.input.InputMethodHighlight.html">InputMethodHighlight</a>
</li>
<li class="profile-common conditional input_method ">
<a href="javafx.scene.input/javafx.scene.input.InputMethodTextRun.html">InputMethodTextRun</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.input/javafx.scene.input.KeyCode.html">KeyCode</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.input/javafx.scene.input.KeyEvent.html">KeyEvent</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.input/javafx.scene.input.KeyEventID.html">KeyEventID</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.input/javafx.scene.input.MouseButton.html">MouseButton</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.input/javafx.scene.input.MouseEvent.html">MouseEvent</a>
</li>
<li class="profile-common private">
<a href="javafx.scene.input/javafx.scene.input.MouseEventID.html">MouseEventID</a>
</li>
<li class="profile-common conditional input_method ">
<a href="javafx.scene.input/javafx.scene.input.TextInput.html">TextInput</a>
</li>
<li class="private">
<a href="javafx.scene.input/javafx.scene.input.TextInput.impl_InputMethodEventHandler.html">TextInput.impl_InputMethodEventHandler</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.layout</a>
</h4>
<ul class="content">
<li class="">
<a href="javafx.scene.layout/javafx.scene.layout.ClipView.html">ClipView</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.Container.html">Container</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.Flow.html">Flow</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.HBox.html">HBox</a>
</li>
<li class="">
<a href="javafx.scene.layout/javafx.scene.layout.LayoutInfo.html">LayoutInfo</a>
</li>
<li class="">
<a href="javafx.scene.layout/javafx.scene.layout.LayoutInfoBase.html">LayoutInfoBase</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.Panel.html">Panel</a>
</li>
<li class="">
<a href="javafx.scene.layout/javafx.scene.layout.Priority.html">Priority</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a>
</li>
<li class="">
<a href="javafx.scene.layout/javafx.scene.layout.Stack.html">Stack</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.Tile.html">Tile</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.layout/javafx.scene.layout.VBox.html">VBox</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.media</a>
</h4>
<ul class="content">
<li class="">
<a href="javafx.scene.media/javafx.scene.media.AudioTrack.html">AudioTrack</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.Media.html">Media</a>
</li>
<li class="">
<a href="javafx.scene.media/javafx.scene.media.Media.Metadata.html">Media.Metadata</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.MediaError.html">MediaError</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.MediaPlayer.html">MediaPlayer</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.MediaTimer.html">MediaTimer</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.MediaView.html">MediaView</a>
</li>
<li class="">
<a href="javafx.scene.media/javafx.scene.media.SubtitleTrack.html">SubtitleTrack</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.media/javafx.scene.media.Track.html">Track</a>
</li>
<li class="">
<a href="javafx.scene.media/javafx.scene.media.TrackType.html">TrackType</a>
</li>
<li class="">
<a href="javafx.scene.media/javafx.scene.media.VideoTrack.html">VideoTrack</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.paint</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.Color.html">Color</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.CycleMethod.html">CycleMethod</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.LinearGradient.html">LinearGradient</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.Paint.html">Paint</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.RadialGradient.html">RadialGradient</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.paint/javafx.scene.paint.Stop.html">Stop</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.shape</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Arc.html">Arc</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.ArcTo.html">ArcTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.ArcType.html">ArcType</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Circle.html">Circle</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.ClosePath.html">ClosePath</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.CubicCurve.html">CubicCurve</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.CubicCurveTo.html">CubicCurveTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.DelegateShape.html">DelegateShape</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Ellipse.html">Ellipse</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.FillRule.html">FillRule</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.HLineTo.html">HLineTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Line.html">Line</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.LineTo.html">LineTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.MoveTo.html">MoveTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Path.html">Path</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.PathElement.html">PathElement</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Polygon.html">Polygon</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Polyline.html">Polyline</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.QuadCurve.html">QuadCurve</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.QuadCurveTo.html">QuadCurveTo</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Rectangle.html">Rectangle</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.SVGPath.html">SVGPath</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.Shape.html">Shape</a>
</li>
<li class="profile-desktop ">
<a href="javafx.scene.shape/javafx.scene.shape.ShapeIntersect.html">ShapeIntersect</a>
</li>
<li class="profile-desktop ">
<a href="javafx.scene.shape/javafx.scene.shape.ShapeSubtract.html">ShapeSubtract</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.StrokeLineCap.html">StrokeLineCap</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.StrokeLineJoin.html">StrokeLineJoin</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.shape/javafx.scene.shape.VLineTo.html">VLineTo</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.text</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.Font.html">Font</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.FontPosition.html">FontPosition</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.FontPosture.html">FontPosture</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.FontWeight.html">FontWeight</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.Text.html">Text</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.TextAlignment.html">TextAlignment</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.TextBoundsType.html">TextBoundsType</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.TextOffsets.html">TextOffsets</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.text/javafx.scene.text.TextOrigin.html">TextOrigin</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.scene.transform</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Affine.html">Affine</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Rotate.html">Rotate</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Scale.html">Scale</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Shear.html">Shear</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Transform.html">Transform</a>
</li>
<li class="profile-common ">
<a href="javafx.scene.transform/javafx.scene.transform.Translate.html">Translate</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.stage</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.stage/javafx.stage.Alert.html">Alert</a>
</li>
<li class="profile-desktop ">
<a href="javafx.stage/javafx.stage.AppletStageExtension.html">AppletStageExtension</a>
</li>
<li class="profile-common ">
<a href="javafx.stage/javafx.stage.Screen.html">Screen</a>
</li>
<li class="profile-common ">
<a href="javafx.stage/javafx.stage.Stage.html">Stage</a>
</li>
<li class="profile-common ">
<a href="javafx.stage/javafx.stage.StageExtension.html">StageExtension</a>
</li>
<li class="profile-common ">
<a href="javafx.stage/javafx.stage.StageStyle.html">StageStyle</a>
</li>
</ul>
</li>
<li>
<h4 class="header">
<a href="#">javafx.util</a>
</h4>
<ul class="content">
<li class="profile-common ">
<a href="javafx.util/javafx.util.Bits.html">Bits</a>
</li>
<li class="profile-desktop ">
<a href="javafx.util/javafx.util.FXEvaluator.html">FXEvaluator</a>
</li>
<li class="profile-common ">
<a href="javafx.util/javafx.util.Math.html">Math</a>
</li>
<li class="profile-common ">
<a href="javafx.util/javafx.util.Properties.html">Properties</a>
</li>
<li class="profile-common ">
<a href="javafx.util/javafx.util.Sequences.html">Sequences</a>
</li>
<li class="profile-desktop ">
<a href="javafx.util/javafx.util.StringLocalizer.html">StringLocalizer</a>
</li>
</ul>
</li>
<li id="copyright">
<i>Copyright (c) 2008, 2010,</i>
<br>
<i>Oracle and/or its affiliates.</i>
<br>
<i>All rights reserved.</i>
<br>
<i>Use is subject to <a href="http://java.sun.com/javafx/1.3/docs/api/license.html">license terms</a>.</i>
<br>
</li>
</ul>
<div id="content">
<h3>JavaFX 1.3.1 API |  Overview  | Java FX</h3>
<table class="package-docs">
<tr>
<th></th>
</tr>
<tr>
<td class="name"><b>com.javafx.preview.control</b></td><td class="description">
<p class="comment"><p>This package contains a collection of experimental/preview controls that
    <strong> are not final and will change in future releases</strong>.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>This package contains a collection of experimental/preview controls that
    <strong> are not final and will change in future releases</strong>.
    Eventually it is intended that these controls will transition from the
    com.javafx.preview.control package to the javafx.scene.control package.</p>
    
    <p>These controls have been made available for early adopters to experiment
    with in the hopes that doing so will provide useful feedback to help make
    the JavaFX UI Controls library the most powerful and pleasing UI Controls
    library available. If you have any feedback on these controls, either as
    requests for enhancement or as bug reports, please report them all to the
    <a href="http://javafx-jira.kenai.com">JavaFX JIRA issue tracker</a>.</p>

    <p>For more information on the official controls that are part of the JavaFX
    release, as well as details on the controls architecture and how to style
    controls, refer to the <code>javafx.scene.control</code>
    package information page.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>com.javafx.preview.layout</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.animation</b></td><td class="description">
<p class="comment"><p>The <code>javafx.animation</code> package provides a set of classes
that implement a time-based animation framework.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>The <code>javafx.animation</code> package provides a set of classes
that implement a time-based animation framework. This framework allows
an application to define values for a set of variables at particular
points in time, thus creating a mapping from time to value for each
target variable.</p>

<p>The two primary classes in this package are:</p>

<ul>

<li><a href="afx.animation.Timeline Timeline">Timeline</a> &ndash; Controls the execution of a sequence of
key frames, processing each <a href="afx.animation.KeyFrame KeyFrame">KeyFrame</a> sequentially, in the
order specified by the <code>KeyFrame.time</code> variable. The
<code>repeatCount</code> variable specifies how many times a
<code>Timeline</code> will run before stopping, or specifies that the
<code>Timeline</code> will run indefinitely (until explicitly
stopped). A <code>Timeline</code> that runs more than once will
restart each pass at the beginning of the <code>Timeline</code>,
unless the <code>autoReverse</code> flag is set, which will cause the
<code>Timeline</code> to reverse direction for each pass.<br><br></li>

<li><a href="afx.animation.KeyFrame KeyFrame">KeyFrame</a> &ndash; Defines target values at a specified
point in time for a set of variables that are interpolated along a
<a href="afx.animation.Timeline Timeline">Timeline</a>. A <code>KeyFrame</code> optionally defines an action function
that is called when the <code>KeyFrame</code> is executed</li>

</ul>

<p>Each variable in the <code>Timeline</code> transitions between the declared
values at each <code>KeyFrame</code>, by using the declared interpolation
function to calculate the in-between value at that time.
The default interpolator performs linear interpolation, although other
interpolators are available (for example, EASEIN, EASEOUT, and EASEBOTH).
</p>

<p>These interpolated variables can then be used to control various
rendering attributes (such as position), or for any other use desired
by the application.</p>

<p>For example:</p>

<ul>
<pre>
import javafx.animation.Timeline;
import javafx.animation.KeyFrame;

var x:Number;

var tl = Timeline {
    keyFrames: [
        KeyFrame {
            time: 0s
            values: x => 1.0
        }
        KeyFrame {
            time: 2s
            values: x => 5.0
        }
    ]
}
</pre>
</ul>

<p>When the above <code>Timeline</code> is played, the variable <code>x</code> will
linearly transition from a value of 1.0 at time = 0 seconds (that is,
right after the <code>Timeline</code> starts playing) to a value of 5.0 at time = 2
seconds.</p>

<p>Note that the JavaFX compiler has built-in support for animation.
Along with the <code>=&gt;</code> operator, the  <code>at()</code>
pseudo-function makes defining a KeyFrame and its associated key
values even easier:</p>

<ul>
<pre>
import javafx.animation.Timeline;

var x:Number;

var tl = Timeline {
    keyFrames: [
        at(0s) { x => 1.0 }
        at(2s) { x => 5.0 }
    ]
}
</pre>
</ul>

<p>In addition to defining key values, a <code>KeyFrame</code> can have an action
associated with it. This action function is called when the <code>Timeline</code>
reaches the particular point in time.</p>

<p>For example:</p>

<ul>
<pre>
import javafx.animation.Timeline;
import javafx.animation.KeyFrame;
import javafx.animation.Interpolator;

var x:Number;
var y:Number;

var tl = Timeline {
    repeatCount: Timeline.INDEFINITE
    keyFrames: [
        at(0s) { x => 1.0; y => 3.0 }
        at(2s) { x => 4.0 }
        at(4s) { x => 5.0; y => 12.0 tween Interpolator.EASEBOTH }
        KeyFrame {
            time: 4s
            action: function() {
                println("done with cycle");
            }
        }
    ]
}
</pre>
</ul>

<p>In this example, <code>x</code> will linearly interpolate from 1.0
to 4.0 over the first 2 seconds, and then from 4.0 to 5.0 over the
next 2 seconds. Because there is no value for <code>y</code> defined
at time = 2 seconds, <code>y</code> will interpolate from 3.0
to 12.0 over 4 seconds using an easing interpolator at the beginning
and end of the interval.
At the end of 4 seconds the final <code>KeyFrame</code>
will execute its action function and print the message <code>"done
with cycle"</code>. The final <code>KeyFrame</code> uses an explicit object
literal because there is no shorthand form that includes the action
function.</p>

<p>Note that this <code>Timeline</code> has a <code>repeatCount</code> of
<code>INDEFINITE</code>, so it will run continuously, starting over at
time = 0 every 4 seconds, immediately after executing the
<code>KeyFrame</code>(s) at time = 4 seconds.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.animation.transition</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for ease of use transition based animations.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for ease of use transition based animations.</p>
<p>It offers a simple framework for incorporating animations onto an internal
<a href="afx.animation.transition.Timeline Timeline">Timeline</a>. It also provides high level constructs to compose the effects
of multiple animations.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.async</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for javafx.async.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for javafx.async.</p>
<p>This package provides the ability to run application code on threads other
than the JavaFX event dispatch thread.  The ability to control the execution
and track the progress of the application code is also provided.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.data</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.data.feed</b></td><td class="description">
<p class="comment"><p>This package contains the base classes for an Atom or RSS document.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>This package contains the base classes for an Atom or RSS document.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.data.feed.atom</b></td><td class="description">
<p class="comment"><p>This package contains all the data structures for parsing a document
that conforms to the 
<a href="http://www.ietf.org/rfc/rfc4287.txt">Atom Syndication Format</a></p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>This package contains all the data structures for parsing a document
that conforms to the 
<a href="http://www.ietf.org/rfc/rfc4287.txt">Atom Syndication Format</a>
</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.data.feed.rss</b></td><td class="description">
<p class="comment"><p>This package contains all the data structures for parsing an RSS document.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>This package contains all the data structures for parsing an RSS document.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.data.pull</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.data.xml</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.date</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.ext.swing</b></td><td class="description">
<p class="comment"><p>Provides the set of graphical user interface component classes that, to the 
maximum degree possible, work the same on all platforms.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of graphical user interface component classes that, to the 
maximum degree possible, work the same on all platforms.</p>
<p>This is a second paragraph test.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.fxd</b></td><td class="description">
<p class="comment">Provides functionality to load JavaFX graphic files (FXD and FXZ format)
 that are generated by JavaFX Production Suite.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment">Provides functionality to load JavaFX graphic files (FXD and FXZ format)
 that are generated by JavaFX Production Suite.

 JavaFX graphic format files contains text descriptions of the graphical content of the JavaFX
 application. Descriptions are loaded by this package
 into the application during runtime. 

 JavaFX graphic format exists in two forms, FXD and FXZ. FXD
 is a textual 
 format using the same object literal syntax as JavaFX Script, so it is possible
to copy and paste the descriptions from the FXD file directly into
JavaFX Script code (with some exceptions noted at the end of this section).
Here is an example of a simple
FXD file representing a smiley face graphic:

<pre>
FXD {
  content: [
    Circle { id:"background" centerX:40 centerY:40 radius:39
             fill:Color.YELLOW stroke:Color.BLACK strokeWidth:3.0},
    Circle { centerX:25 centerY:30 radius:5 fill: Color.BLACK},
    Circle { centerX:55 centerY:30 radius:5 fill: Color.BLACK},
    Line{ startX:32 startY:23 endX:16 endY:15 stroke:Color.BLACK strokeWidth:4.0},
    Line{ startX:45 startY:23 endX:61 endY:15 stroke:Color.BLACK strokeWidth:4.0},
    QuadCurve { id: "mouth" stroke:Color.BLACK  strokeWidth:3.0 fill: Color.TRANSPARENT
                startX:20 startY:60 endX:60 endY:60 controlX:40 controlY:80
    }
  ]
}
</pre>

The content is loaded using the <a href="javafx.fxd/javafx.fxd.FXDLoader.html">javafx.fxd.FXDLoader</a> class. It
can be inserted into the scene graph using this snippet of code:
<pre>
var group:Group .... // a graphics group defined elsewhere 
var smileyNode = FXDLoader.load("{__DIR__}smiley.fxd"}; // loads the content
insert smileyNode into group.content; // inserts the smiley into the group
</pre>

It is possible to reference external assets from FXD content. The FXD description
follows the same approach as JavaFX Script, using the <code>{__DIR__}</code> magic variable. 
The following example demonstrates how to reference embedded font and image files
in the FXD description. All of the files are stored in an FXZ file called <code>mygfx.fxz</code>:

<pre>
FXD {
  content: [
    ImageView { x: 10 y: 10
               image: Image{ url: "{__DIR__}myimage.png"}
    },
    Text { fill: Color.WHITE x: 20 y: 20 textOrigin: TextOrigin.TOP
           font: Font.fontFromURL("{__DIR__}myfont.ttf", 25.00)
           content: "Welcome !!!"
    },
  ]
}
</pre>

In the above example, the root contains two nodes - <code>ImageView</code> with
<code>Image</code>, which loads its content from the <code>myimage.png</code> file. The other node is a <code>Text</code>
node and it uses a custom font with size 25. The font is loaded from the  <code>myfont.ttf</code> 
file. Both, the image and the font files are located in the same
directory as the <code>mygfx.fxd</code> file itself.

<b>FXZ</b> is simply a compressed version of the FXD content using zip compression
and file format. The FXZ file can also contain embedded assets, such as images or fonts.
The structure of the FXZ file from the example above is as follows:

<pre>
mygfx.fxz
 +- content.fxd
 +- myimage.png
 +- myfont.ttf
 +- ...
</pre>

The <code>content.fxd</code> file is the main content of the FXZ archive, containing the description of the graphic objects. The other 
files, <code>myimage.png</code> and <code>myfont.ttf</code> are the embedded image and font assets. 

FXZ files can be loaded in exactly the same way as FXD files, using
the <a href="javafx.fxd/javafx.fxd.FXDLoader.html">javafx.fxd.FXDLoader</a> class. 

FXD format follows similar object literal syntax as JavaFX Script.
This makes FXD format highly compatible with JavaFX Script, and it
is possible to copy portions of the FXD content directly to the JavaFX script code.

Detailed FXD format specification is available <a href="http://java.sun.com/javafx/1.3/docs/fxdspec/">here</a>.
<p>&nbsp;</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.geometry</b></td><td class="description">
<p class="comment"><p>Provides the set of 2D classes for defining and performing operations on 
objects related to two-dimensional geometry.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of 2D classes for defining and performing operations on 
objects related to two-dimensional geometry. </p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.io</b></td><td class="description">
<p class="comment"><p>Provides basic IO facility for JavaFX scripts.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides basic IO facility for JavaFX scripts.</p>

<p>The main areas of functionality of <code>javafx.io</code> package include </p>
<ol>
  <li>
    <p><b>Storage:</b> Represents each storage entry in the system. Also
provides APIs for application wide statistics & operations.</p>
  </li>
  <li>
    <p><b>Resource:</b> Provides a view of contents of a single stored entity.</p>
  </li>
</ol></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.io.http</b></td><td class="description">
<p class="comment"><p>This package contains the classes for communicating via HTTP.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>This package contains the classes for communicating via HTTP.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.lang</b></td><td class="description">
<p class="comment">This package provides JavaFX Script Runtime APIs</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment">This package provides JavaFX Script Runtime APIs
 <p>
 <h2>Builtins</h2>
 This class is automatically imported to all JavaFX Scripts
 </p>
 <h2>FX</h2>
 The FX class contains number of static entry points
 for a couple of different API sets provided by JavaFX Script.
 <ul>
 <li> Application Model
 <p>JavaFX Script APIs are categorized into following profiles.   </p>
 <ul>
 <li>Common Profile
 <p>This API is common across all platforms</p>
 <li>Desktop Profile
 <p>This API is available only in the desktop environment
 (browser & standalone)</p>
 <li>Mobile Profile
 <p>This API is available only in the mobile environment.</p>
 </ul>
 <p>If an application needs to be portable across all screens,
 it has to limit itself to common profile APIs. The JavaFX Script
 Runtime has the ability to run JavaFX Scripts
 that use the common or desktop API sets in any supported Browser.
 </p>
 <li> Argument or Parameter Handling
 <p>JavaFX Scripts can get Arguments or Parameters in 2 different 
 forms
 <ul><li>Named
 <p>Named Parameters come in the form of a Name, Value pair typically
 from HTML, JAD or JNLP files. They can also be passed as a commandline
 argument in the form of "name=value".</p>
 <p>Use the <a href="javafx.lang/javafx.lang.FX.html#getArgument(java.lang.String)">getArgument()</a>
 api for Named parameters</p>
 <li>Unnamed
 <p>Unnamed Arguments are always passed on the commandline.
 <p>Use the <a href="javafx.lang/javafx.lang.FX.html#getArguments()">FX.getArguments()</a>
 api for Named parameters</p>
 </ul>
 These <b>cannot</b> be combined, if they are it will behave as space
 seperated arguments.</p>
 <li> SystemProperty information
 </ul></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.reflect</b></td><td class="description">
<p class="comment">Provides reflective access to JavaFX values and types.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment">Provides reflective access to JavaFX values and types.

 This packages defines a Java API (rather than a JavaFX API), 
 so it can be used from both Java and JavaFX code.
 A future JavaFX API may be layered on top of this.

 <h2>Context</h2>
 The objects in this package are directly or indirectly created
 from a <a href="javafx.reflect/javafx.reflect.FXContext.html">FXContext</a>.
 In the default case there is a single <code>FXContext</code> instance that
 uses Java reflection.  You get one of these by doing:
 <pre>
 FXLocal.Context ctx = FXLocal.getContext();
 </pre>
 Alternatively, you can do:
 <pre>
 FXContext ctx = FXContext.getInstance();
 </pre>
 The latter is more abstract (as it supports proxying for remote VMs)
 but the more specific <code>FXLocal.Context</code> supports some extra
 operations that only make sense for same-VM reflection.

 <h2>Values</h2>
 The various reflection operations do not directly use
 Java values.  Instead,
 an <a href="javafx.reflect/javafx.reflect.FXObjectValue.html">javafx.reflect.FXObjectValue</a> is a <q>handle</q> or
 proxy for an <code>Object</code>.  This extra layer of indirection
 isn't needed in many cases, but it is useful for remote invocation,
 remote control, or in general access to data in a different VM.

 <h2>Object creation</h2>
 To do the equivalent of the JavaFX code:
 <blockquote><pre>
 var x = ...;
 var z = Foo { a: 10; b: bind x.y };
 </pre></blockquote>
 you can do:
 <blockquote><pre>
 FXContext rcontext = ...;
 FXClassType cls = rcontext.findClass(...);
 FXObjectValue x = ...;
 FXObjectValue z = cls.allocation();
 z.initVar("a", ???);
 z.bindVar("b", ???);
 z.initialize();
 </pre></blockquote>

 <h2>Sequence operations</h2>
 <p>
 Use <a href="javafx.reflect/javafx.reflect.FXSequenceBuilder.html">javafx.reflect.FXSequenceBuilder</a> to create a new sequence.
 <p>
 To get the number of items in a sequence,
 use <a href="javafx.reflect/javafx.reflect.FXValue.html#getItemCount()">ValueRef.getItemCount</a>.
 To index into a sequence,
 use <a href="javafx.reflect/javafx.reflect.FXValue.html#getItem(int)">ValueRef.getItem</a>.

 <h2>Design notes and issues</h2>
 Some design principles, influenced by the "Mirrored reflection"
 APIs (<a href="http://bracha.org/mirrors.pdf">Bracha and Ungar:
 <cite>Mirrors: Design Principles for Meta-level Facilities
 of Object-Oritented Programming Languages</cite>, OOPSLA 2004</a>),
 and <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/">JDI</a> :
 <ul>
 <li>No explicit constructors in user code.
 <li>Keep everything abstract, and allow indirection.
 For example, we might be working on objects in the current VM,
 or a remote VM.  We might not have objects at all - a subset of the same API
 might be used for (say) reading from <code>.class</code> files.
 <li>Hence the core classes are interfaces or abstract.
 <li>On the other hand, we should avoid useless levels of indirection
 or "service lookup".
 </ul>

 <h2>Limitations</h2>
 <ul>
 <li>Error handling isn't very consistent - sometimes we return null, and
 sometimes we throw an exception.
 <li>We don't support bound functions properly.
 </ul></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.runtime</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.scene</b></td><td class="description">
<p class="comment"><p>Provides the core set of base
classes for the JavaFX Scene Graph API.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the core set of base
classes for the JavaFX Scene Graph API. A scene graph is a tree-like
data structure, where each item in the tree has zero or one parent and
zero or more children.</p>

<p>The two primary classes in this package are:</p>

<ul>

<li><a href="javafx.scene/javafx.scene.Scene.html">Scene</a> &ndash; Defines the scene to be rendered. It
contains a <code>fill</code> variable that specifies the background of
the scene, <code>width</code> and <code>height</code> variables that
specify the size of the scene, and a <code>content</code> sequence
that contains a list of "root" <code>Nodes</code> to be rendered onto
the scene. This sequence of <code>Nodes</code> is the scene graph for
this <code>Scene</code>.
A <code>Scene</code> is rendered onto a <a href="javafx.stage/javafx.stage.Stage.html">javafx.stage.Stage</a>, which is the
top-level container for JavaFX content.<br><br></li>

<li><a href="javafx.scene/javafx.scene.Node.html">Node</a> &ndash; Abstract base class for all nodes in the
scene graph. Each node is either a "leaf" node with no child nodes or
a "branch" node with zero or more child nodes. Each node in the tree
has zero or one parent. Only a single node within each tree in the
scene graph will have no parent, which is often referred to as the
"root" node.
There may be several trees in the scene graph. Some trees may be part of
a <a href="javafx.scene/javafx.scene.Scene.html">Scene</a>, in which case they are eligible to be displayed.
Other trees might not be part of any <a href="javafx.scene/javafx.scene.Scene.html">Scene</a>.</li>

</ul>

<p>Branch nodes are of type <a href="javafx.scene/javafx.scene.Parent.html">Parent</a>, whose concrete subclasses
are <a href="javafx.scene/javafx.scene.Group.html">Group</a>, <a href="javafx.scene.layout/javafx.scene.layout.Container.html">javafx.scene.layout.Container</a>,
<a href="javafx.scene.control/javafx.scene.control.Control.html">javafx.scene.control.Control</a>, <a href="javafx.scene/javafx.scene.CustomNode.html">CustomNode</a>, or
subclasses thereof.</p>

<p>Leaf nodes are classes such as
<a href="javafx.scene.shape/javafx.scene.shape.Rectangle.html">javafx.scene.shape.Rectangle</a>, <a href="javafx.scene.text/javafx.scene.text.Text.html">javafx.scene.text.Text</a>,
<a href="afx.scene.image.ImageView">javafx.scene.image.ImageView</a>, <a href="javafx.scene.media/javafx.scene.media.MediaView.html">javafx.scene.media.MediaView</a>,
or other such leaf classes which cannot have children.

<p>A node may occur at most once anywhere in the scene
graph. Specifically, a node must appear no more than once in all of
the following: in the content sequence of a <a href="javafx.scene/javafx.scene.Scene.html">Scene</a>, in the
children sequence of a <a href="javafx.scene/javafx.scene.Parent.html">Parent</a> (for example, in a
<a href="javafx.scene/javafx.scene.Group.html">Group</a> node's content sequence), or as the clip of a
<a href="javafx.scene/javafx.scene.Node.html">Node</a>.
See the <a href="javafx.scene/javafx.scene.Node.html">Node</a> class for more details on these restrictions.</p>

<h4>Example</h4>

<p>An example JavaFX scene graph is as follows:</p>

<ul>
<pre>
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.text.Font;
import javafx.scene.text.Text;

Scene {
    width: 200
    height: 150
    fill: Color.LIGHTGRAY
    content: [
        Circle {
            centerX: 60
            centerY: 40
            radius: 30
            fill: Color.GREEN
        },
        Text {
            x: 10
            y: 90
            font: Font { size: 20 }
            content: "JavaFX Scene"
            fill: Color.DARKRED
        }
    ]
}
</pre>
</ul>

<p>The above example will generate the following image:</p>

<!-- TODO workaround for broken relative links from pkg docs -->
<ul><img src="javafx.scene/doc-files/Scene1.png"/></ul>

<h4>Coordinate System and Transformations</h4>

<p>The <code>Node</code> class defines a traditional computer graphics "local"
coordinate system in which the <code>x</code> axis increases to the right and the
<code>y</code> axis increases downwards. The concrete node classes for shapes
provide variables for defining the geometry and location of the shape
within this local coordinate space. For example,
<a href="javafx.scene.shape/javafx.scene.shape.Rectangle.html">javafx.scene.shape.Rectangle</a> provides <code>x</code>, <code>y</code>,
<code>width</code>, <code>height</code> variables while
<a href="javafx.scene.shape/javafx.scene.shape.Circle.html">javafx.scene.shape.Circle</a> provides <code>centerX</code>, <code>centerY</code>,
and <code>radius</code>.</p>

<p>Any <code>Node</code> can have transformations applied to it. These include
translation, rotation, scaling, or shearing transformations. A transformation
will change the position, orientation, or size of the coordinate system as
viewed from the parent of the node that has been transformed.</p>

<p>See the <a href="javafx.scene/javafx.scene.Node.html">Node</a> class for more information on transformations.</p>

<h4>Bounding Rectangle</h4>

<p>Since every <code>Node</code> has transformations, every Node's geometric
bounding rectangle can be described differently depending on whether
transformations are accounted for or not.</p>

<p>Each <code>Node</code> has the following read-only variables which
specifies these bounding rectangles:</p>

<ul>

<li><code>boundsInLocal</code> &ndash; specifies the bounds of the
<code>Node</code> in untransformed local coordinates.<br><br></li>

<li><code>boundsInParent</code> &ndash; specifies the bounds of the
<code>Node</code> after all transformations have been applied.
It is called "boundsInParent" because the
rectangle will be relative to the parent's coordinate system.<br><br></li>

<li><code>layoutBounds</code> &ndash; specifies the rectangular bounds of
the <code>Node</code> that should be used as the basis for layout
calculations, and may differ from the visual bounds of the node. For
shapes, Text, and ImageView, the default <code>layoutBounds</code> includes
only the shape geometry.</li>

</ul>

<p>See the <a href="javafx.scene/javafx.scene.Node.html">Node</a> class for more information on bounding rectangles.</p>

<h4>CSS</h4>
<p>
The JavaFX Scene Graph provides the facility to style nodes using
CSS (Cascading Style Sheets).
The <a href="javafx.scene/javafx.scene.Node.html">Node</a> class contains <code>id</code>, <code>styleClass</code>, and
<code>style</code> variables are used by CSS selectors to find nodes
to which styles should be applied. The <a href="javafx.scene/javafx.scene.Scene.html">Scene</a> class contains
the <code>stylesheets</code> variable which is a sequence of URLs that
reference CSS style sheets that are to be applied to the nodes within
that scene.
<p>
For further information about CSS, how to apply CSS styles
to nodes, and what properties are available for styling, see the
<!-- TODO workaround for broken relative links from package docs -->
<a href="javafx.scene/doc-files/cssref.html">CSS Reference Guide</a>.</p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.chart</b></td><td class="description">
<p class="comment"><p>The JavaFX User Interface provides a set of chart components that
    are a very convenient way for data visualization.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>The JavaFX User Interface provides a set of chart components that
    are a very convenient way for data visualization. Application
    developers can make use of these off-the-rack graphical charts
    provided by the SDK, to visualize a wide variety of data.</p>

    <p>Commom types of charts such as <a href="javafx.scene.chart/javafx.scene.chart.BarChart.html">Bar</a>, <a href="javafx.scene.chart/javafx.scene.chart.LineChart.html">Line</a>,
    <a href="javafx.scene.chart/javafx.scene.chart.AreaChart.html">Area</a>, <a href="javafx.scene.chart/javafx.scene.chart.PieChart.html">Pie</a>, <a href="javafx.scene.chart/javafx.scene.chart.ScatterChart.html">Scatter</a> and <a href="javafx.scene.chart/javafx.scene.chart.BubbleChart.html">Bubble</a> charts are provided. These
    charts are easy to create and are customizable. JavaFX Charts API is
    a visual centric API rather than model centric. There are several
    public variables provided for charts that can be customized either
    programmatically or via CSS.</p>

    <p>JavaFX Charts API is modular and extendable. <a href="javafx.scene.chart/javafx.scene.chart.PieChart3D.html">PieChart3D</a> and <a href="javafx.scene.chart/javafx.scene.chart.BarChart3D.html">BarChart3D</a> are two such examples that
    extend from PieChart and BarChart respectively to form new Chart
    types.</p>
    
    <p>Below is a table listing the existing Chart types and a brief
    summary of their intended use.</p>

    <table>
	<tr>
		<th>
			<p>Chart</p>
		</th>
		<th>
			<p>Summary</p>
		</th>
	</tr>
	<tr>
		<td>
			<p><a href="eChart">LineChart</a></p>
		</td>
		<td>
			<p>Plots line between the data points in a series. Used usually to
			view data trends over time.</p>
		</td>
	</tr>
	<tr>
		<td>
			<p><a href="aChart">AreaChart</a></p>
		</td>
		<td>
			<p>Plots the area between the line that connects the data points
			and the axis. Good for comparing cumulated totals over time.</p>
		</td>
	</tr>
	<tr>
		<td>
			<p><a href="Chart">BarChart</a></p>
		</td>
		<td>
			<p>Plots rectangular bars with heights indicating data values they
			represent, and corresponding to the categories they belongs to.
			Used for displaying discontinuous / discrete data</p>
		</td>
	</tr>
	<tr>
		<td>
			<p><a href="Chart">PieChart</a></p>
		</td>
		<td>
			<p>Plots circular chart divided into segments with each segment
			representing a value as a proportion of the total. It looks like a
			Pie and hence the name 
			</p>
		</td>
	</tr>
	<tr>
		<td>
			<p><a href="bleChart">BubbleChart</a></p>
		</td>
		<td>
			<p>Plots bubbles for data points in a series. Each plotted entity
			depicts three parameters in a 2D chart and hence a unique chart
			type.</p>
		</td>
	</tr>
	<tr>
		<td>
			<p><a href="tterChart">ScatterChart</a></p>
		</td>
		<td>
			<p>Plots symbols for the data points in a series. This type of
			chart is useful in viewing distribution of data and its
			corelation, if there is any clustering.</p>
		</td>
	</tr>
    </table>

    <p>The <a href="javafx.scene.chart/javafx.scene.chart.Chart.html">javafx.scene.chart.Chart</a> is the baseclass for all charts. It is responsible
    for drawing the background, frame, title and legend. It can be extended to create custom chart types.
    The <a href="javafx.scene.chart/javafx.scene.chart.XYChart.html">javafx.scene.chart.XYChart</a> is the baseclass for all two axis charts and it extends from
    Chart class. It is mostly responsible for drawing the two axis and the background of the chart plot.
    Most charts extend from XYChart class except for PieChart which extends from Chart class as it
    is not a two axis chart.
    </p>
    
    <p>The <a href="afx.scene.chart.part">javafx.scene.chart.part</a> package includes axis classes that can be used when creating
    two axis charts. <a href="afx.scene.chart.data.Axis">javafx.scene.chart.data.Axis</a> is the abstract base class of all chart axis.
    <a href="javafx.scene.chart.part/javafx.scene.chart.part.CategoryAxis.html">javafx.scene.chart.part.CategoryAxis</a> plots string categories where
    each value is a unique category along the axis. <a href="afx.scene.chart.NumberAxis">javafx.scene.chart.NumberAxis</a> plots
    a range of numbers with major tick marks every tickUnit.
    </p>

    <p>The <a href="afx.scene.chart.data">javafx.scene.chart.data</a> package has Data and Series classes that are used as a basis
    for defining chart data. Chart contains one or several series of data.
    </p>

    <p>For Example BarChart plots data from a sequence of <a href="javafx.scene.chart/javafx.scene.chart.BarChart.Series.html">javafx.scene.chart.BarChart.Series</a> objects.
    Each series contains <a href="javafx.scene.chart/javafx.scene.chart.BarChart.Data.html">javafx.scene.chart.BarChart.Data</a> objects.
    </p>

    <ul>
    <pre>
    def barSeries1: BarChart.Series = BarChart.Series {
        name: "Anvils"
        BarChart.Data {
            Category: "2007"
            Value: 567
        }
    }
    </pre>
    </ul>
    <p>We can define more series objects similarly. Following code snippet shows
    how to create a BarChart with 3 categories and its X and Y axis:
    </p>
    <ul>
   <pre>
    def barchart = BarChart {
        title: "Title" titleFont: Font { size: 24 }
        categoryAxis: CategoryAxis {
        categories: ["2007", "2008", "2009"]
    }
    valueAxis: NumberAxis {
        label: "Units Sold"
        UpperBound: 3000
        tickUnit: 1000
    }
    data: [barSeries1, barSeries2, barSeries3]
  }
   </pre>
    </ul>

    <p>JavaFX charts lends itself very well for real time or dynamic Charting (like
    online stocks, web traffic etc) from live data sets. Here is an example of a dynamic
    chart created with simulated data. A <a href="javafx.animation/javafx.animation.Timeline.html">javafx.animation.Timeline</a> is used to
    simulate dynamic data for temperature variations over time(Days).
    </p>

    <ul>
        <pre>
        def DISPLAY_RANGE:Integer = 50;
       
        def xAxis:NumberAxis = NumberAxis {
            label: "Time (Days)"
            lowerBound: 0
            upperBound: DISPLAY_RANGE
            tickUnit: DISPLAY_RANGE/10
            formatTickLabel: function(value):String { "{(value as Float) as Integer}" }
        };
        public def CHART =  LineChart {
            title: "Dynamic Data Sample"
            data: LineChart.Series{
                name: "Random"
            };
            xAxis: xAxis
            yAxis: NumberAxis {
                label: "Temperature"
                lowerBound: -40
                upperBound: 100
                tickUnit: 20
            }
        }
        var currentDay = 0;
        def timeline:Timeline = Timeline{
            repeatCount: Timeline.INDEFINITE
            keyFrames: KeyFrame {
                time: 0.2s
                action: function() {
                    if (currentDay > DISPLAY_RANGE) {
                        delete series.data[0];
                        xAxis.lowerBound = currentDay-DISPLAY_RANGE;
                        xAxis.upperBound = currentDay;
                    }
                    insert LineChart.Data{
                        xValue: currentDay
                        yValue: (javafx.util.Math.random() * 130) -35
                    } into series.data;
                    currentDay ++;
                }
            }
        }
        </pre>

    </ul></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.chart.data</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.scene.chart.part</b></td><td class="description"></td>
</tr>
<tr>
<td class="name"><b>javafx.scene.control</b></td><td class="description">
<p class="comment"><p>The JavaFX User Interface Controls (UI Controls or just Controls) are
    specialized Nodes in the JavaFX Scenegraph especially suited for reuse in
    many different application contexts.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>The JavaFX User Interface Controls (UI Controls or just Controls) are
    specialized Nodes in the JavaFX Scenegraph especially suited for reuse in
    many different application contexts. They are designed to be highly
    customizable visually by designers and developers. They are designed to work
    well with layout systems, and to be useful for mobile, desktop, web, and tv
    applications. Examples of prominent controls include <a href="javafx.scene.control/javafx.scene.control.Button.html">Button</a>,
    <a href="javafx.scene.control/javafx.scene.control.Label.html">Label</a>, <a href="javafx.scene.control/javafx.scene.control.ListView.html">ListView</a>, and <a href="javafx.scene.control/javafx.scene.control.TextBox.html">TextBox</a>.</p>

    <p>Since Controls are <a href="javafx.scene/javafx.scene.Node.html">Nodes</a> in the scenegraph,
    they can be freely mixed with
    <a href="javafx.scene.layout/javafx.scene.layout.Container.html">Containers</a>,
    <a href="javafx.scene/javafx.scene.Group.html">Groups</a>,
    <a href="afx.scene.image.ImageView Images">Images</a>,
    <a href="javafx.scene.media/javafx.scene.media.MediaView.html">Media</a>,
    <a href="javafx.scene.text/javafx.scene.text.Text.html">Text</a>, and
    <a href="javafx.scene.shape/javafx.scene.shape.Shape.html">basic geometric shapes</a>. While
    writing new UI Controls is not trivial, using and styling them
    is very easy, especially to existing web developers.</p>

    <p>Below is a table listing the existing UI Controls and a brief summary
    of their intended use.</p>

    <table>
        <tr>
            <th>Control</th>
            <th>Summary</th>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Button.html">Button</a></td>
            <td>A simple push button Control, used in most user interfaces for
            invoking an action or command when pressed.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.CheckBox.html">CheckBox</a></td>
            <td>A simple button Control which displays a check or
            mark when selected. Commonly used for displaying multiple choices to
            a user which are not mutually exclusive.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ChoiceBox.html">ChoiceBox</a></td>
            <td>Specializes in presenting the user a list of choices in a popup
            or drop-down list from which the user may select at most one
            item. Especially useful as a non-editable ComboBox with a reasonably
            small set of choices.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Hyperlink.html">Hyperlink</a></td>
            <td>A button Control which looks like a <a href="javafx.scene.control/javafx.scene.control.Label.html">Label</a> and operates
            much like an anchor tag in HTML. The Hyperlink is not tied to
            URLs, but rather, can execute any action when clicked.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Label.html">Label</a></td>
            <td>Simple yet powerful Control for displaying text. If the text
            is too long for the space available, it may be truncated using
            one of several different <a href="javafx.scene.control/javafx.scene.control.OverrunStyle.html">overrun styles</a>. May
            display single or multiple lines of text.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ListView.html">ListView</a></td>
            <td>A powerful multi-row control where each row is defined as a
            <a href="javafx.scene.control/javafx.scene.control.Cell.html">Cell</a>. Supports virtually unlimited numbers of rows. Supports
            dynamically variable non-homogenous row heights. Can be horizontal
            or vertical.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.PasswordBox.html">PasswordBox</a></td>
            <td>Simple password entry control with customizable echo strings
            and optional delay between when a character is typed and when
            it is masked.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ProgressBar.html">ProgressBar</a></td>
            <td>A specialization of the <a href="javafx.scene.control/javafx.scene.control.ProgressIndicator.html">ProgressIndicator</a> which is
            represented as a horizontal or vertical bar.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ProgressIndicator.html">ProgressIndicator</a></td>
            <td>A circular control which is used for indicating progress, either
            infinite (aka indeterminate) or finite. Often used with the
            <a href="javafx.async/javafx.async.Task.html">Task</a> API for representing progress of
            background Tasks.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.RadioButton.html">RadioButton</a></td>
            <td>Typically used with a <a href="javafx.scene.control/javafx.scene.control.ToggleGroup.html">ToggleGroup</a> as a way of forming
            a mutually exclusive set of options from which to choose. This is
            similar in use to a <a href="javafx.scene.control/javafx.scene.control.ChoiceBox.html">ChoiceBox</a>. The RadioButton is the right
            choice when the number of options from which to choose is small.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ScrollBar.html">ScrollBar</a></td>
            <td>Either a horizontal or vertical bar with increment and decrement
            buttons and a "thumb" with which the user can interact. Typically
            not used alone but used for building up more complicated controls
            such as the <a href="javafx.scene.control/javafx.scene.control.ScrollView.html">ScrollView</a> and <a href="javafx.scene.control/javafx.scene.control.ListView.html">ListView</a>.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ScrollView.html">ScrollView</a></td>
            <td>A scrollable viewport within which other Nodes may be placed,
            such as an <a href="afx.scene.image.ImageView ImageView">ImageView</a>.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Separator.html">Separator</a></td>
            <td>A Control used for drawing a horizontal or vertical separator.
            Typically used in connection with ToolBars or Menus.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Slider.html">Slider</a></td>
            <td>A rich and powerful Control for allowing the user to select
            a value from within a range. The range can be limited to discrete
            intervals or be high in precision (limited to the range of a
            Number). The Slider may have an optional set of "tick mark labels"
            for indicating locations within the slider.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.TextBox.html">TextBox</a></td>
            <td>A single-styled single or multi-lined text input Control.
            Suitable for most forms of text entry.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.ToggleButton.html">ToggleButton</a></td>
            <td>A simple button control which may be selected. Can be used with
            a  to form a mutually exclusive set of ToggleButtons.
            Generally used in favor of RadioButtons when displaying a set of
            modes to the user (such as panels to view) as opposed to a set of
            choices the user can chose from.</td>
        </tr>
        <tr>
            <td><a href="javafx.scene.control/javafx.scene.control.Tooltip.html">Tooltip</a></td>
            <td>A type of popup which indicates to the user the function of
            some Control when the Control is hovered over by the mouse.</td>
        </tr>
    </table>

    <p>In addition to the Controls listed here, there are a variety of helper
    classes and mixins which the UI Controls library uses extensively, such as
    <a href="javafx.scene.control/javafx.scene.control.Labeled.html">Labeled</a>, <a href="javafx.scene.control/javafx.scene.control.Cell.html">Cell</a> and <a href="javafx.scene.control/javafx.scene.control.ToggleGroup.html">ToggleGroup</a>. There are also
    a number of <em>preview</em> controls which are available in the
    <code>com.javafx.preview.control</code> package. These Controls <strong> are
    not final and will change in future releases</strong>. However, they have
    been made available for early adopters to experiment with in hopes of
    providing necessary feedback to help make the JavaFX UI Controls library the
    most powerful and pleasing UI Controls library available.</p>

    <p>The remainder of this document will describe the basic architecture of
    the JavaFX UI Control library, how to style existing controls, write custom
    skins, and how to use controls to build up more complicated user interfaces.
    </p>

    <h2>Architecture</h2>

    <p>Controls follow the classic MVC design pattern. The <a href="javafx.scene.control/javafx.scene.control.Control.html">Control</a> is
    the "model". It contains both the state and the functions which manipulate
    that state. The Control class itself does not know how it is rendered or
    what the user interaction is. These tasks are delegated to the
    <a href="javafx.scene.control/javafx.scene.control.Skin.html">Skin</a> ("view") and <a href="javafx.scene.control/javafx.scene.control.Behavior.html">Behavior</a> ("controller") classes
    respectively.</p>

    <p>All Controls extend from the Control class, which is in turn a Parent
    node, and which is both a <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a>
    and a <a href="afx.scene.layout.TextOffsets TextOffsets">TextOffsets</a> (for purposes of
    baseline alignment). Every Control has a reference to a single Skin, which
    is the view implementation for the Control. The Control delegates to the
    Skin the responsibility of computing the min, max, and pref sizes of the
    Control, the baseline offset, and hit testing (containment and
    intersection). The Control delegates to the Behavior all handling of key
    events which occur on the Control when it contains the focus.</p>

    <p>Other than these clearly defined points of delegation, there should be no
    communication from a Control to a Skin or a Behavior. In general, the
    Control worries only about modifying its own internal state. These state
    changes may be exposed to the Skin via bindings or layout changes. Rather
    than having the Control push change notification to the Skin, it is the
    responsibility of the Skin to observe state changes on the Control by using
    binding.</p>

    <p>Likewise, the Behavior should be decoupled from the Skin such that it
    does not communicate directly with a Skin. Instead, the Skin calls functions
    on the behavior in response to input events, and the Behavior then modifies
    state on the control (typically by invoking some function on the control
    which mutates the control's state).</p>

    <p>Thus, when state on the Model (Control) changes, the View (Skin) is
    notified via binding and then updates accordingly. When user interaction
    occurs on the View (Skin), it notifies the Controller (Behavior) which then
    may mutate state on the Model (Control).</p>

    <h2>Control</h2>

    <p>Control extends from <a href="javafx.scene/javafx.scene.Parent.html">Parent</a>, and as such, is
    not a leaf node. From the perspective of a developer or designer the Control
    can be thought of as if it were a leaf node in many cases. For example, the
    developer or designer can consider a Button as if it were a Rectangle or
    other simple leaf node.</p>

    <p>Since it is a <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a>, a Control
    will be <strong>auto-sized to its preferred size</strong> on each scenegraph
    pulse. Setting the width and height of the Control does not affect its
    preferred size. When used in a layout container, the layout constraints
    imposed upon the Control (or manually specified on the Control) will
    determine how it is positioned and sized. In general, any Node in the
    scenegraph can be given a preferred size by setting LayoutConstraints on the
    Node. See the <code>javafx.scene.layout</code> package documentation for more
    information.</p>

    <p>The Skin of a Control can be changed at any time. Doing so will mark the
    Control as needing to be laid out since changing the Skin likely has changed
    the preferred size of the Control. If no Skin is specified at the time that
    the Control is created, then a default CSS-based skin will be provied for
    all of the built-in Controls.</p>

    <p>Each Control may have an optional tooltip specified. The Tooltip is a
    Control which displays some (usually textual) information about the control
    to the user when the mouse hovers over the Control from some period of time.
    It can be styled from CSS the same as with other Controls.</p>

    <p><code>focusTraversable</code> is overridden in Control to be true by default,
    whereas with Node it is false by default. Controls which should not be
    focusable by default (such as Label) override this to be false.
    <code>blocksMouse</code> is also overridden in Control to be true by default
    since users expect most Controls (such as buttons) to consume mouse events.
    Most Controls therefore will block mouse events from reaching nodes which
    are rendered behind them in the scene graph.</p>

    <p>The getMinWidth, getMinHeight, getPrefWidth, getPrefHeight, getMaxWidth,
    and getMaxHeight functions are delegated directly to the Skin. The
    baselineOffset variable is delegated to the node of the skin. It is not
    recommended that subclasses alter these delegations.</p>

    <p>As with all Resizables, the layoutBounds is defined to be based on the
    width and height of the Resizable. It is not recommended to change this
    definition in subclasses.</p>

    <h2>Skin</h2>

    <p>Skin is the abstract class which represents the "view", or visuals, of a
    Control. The Control itself is not responsible for its visual representation
    but instead delegates this to the Skin. The Control contains no visual
    state. There are a few notable exceptions such as textFill on Label and font
    on Labeled. Typically, visual state resides solely on a Skin implementation
    and is set or manipulated from CSS. This design is crucial for allowing for
    wildly different Skin implementations.</p>

    <p>The Skin has a readonly reference to the Control it is currently assigned
    to. A single Skin instance can be used on one and only one Control at a
    time. The Skin also maintains a reference to the Behavior associated with
    that Skin. The behavior variable is readonly, but can be set by Skin
    subclasses. It is the responsibility of the subclass to specify which
    Behavior it uses.</p>

    <p>Default implementations of the getMinWidth, getMinHeight, getPrefWidth,
    getPrefHeight, getMaxWidth, and getMaxHeight functions exist in the Skin
    class. By default, the min width and height is 0, the pref width is 100,
    the pref height is 50, and the max width and height is Float.MAX_VALUE.
    While the min and max defaults are reasonable, the pref width and height
    defaults were chosen so as to be something roughly reasonable (ie: not zero).
    The rationale was to make it easier to get a basic Skin implementation up
    and running. However, these defaults hide an error condition. It is the
    responsibility of a Skin implementation to implement the getPrefWidth and
    getPrefHeight functions, otherwise the Control will always default to be
    100 x 50 (and by virtue of auto-sizing, will be forced to be this size if
    not given different preferred widths and heights). It would be cleaner to
    have made these functions abstract. In a subsequent release these may be
    made abstract. <strong>Skin implementations must always override the
    getPrefWidth and getPrefHeight functions</strong>. It is an error in the
    implementation of the Skin subclass if these functions are not
    overridden.</p>

    <h2>Behavior</h2>

    <p>The last main architectural element is the Behavior class. The Behavior
    is responsible for implementing the user interaction logic of the Control.
    For example, the Button's behavior is responsible for handling the
    press-arm-release semantics used with Buttons. The Control delegates all
    keystrokes to the Behavior when the Control has the focus. The Skin
    delegates all mouse events or other input events that it receives to the
    Behavior so that the behavior may implement the user interaction logic of
    the Control and modify state on the Control as necessary.</p>

    <p>The Behavior API itself is principally comprised of a single function
    callActionForEvent which is called from the Control whenever a key event
    occurs on that Control. This function is not abstract, but under normal
    circumstances a subclass of Behavior will want to override this function and
    provide an implementation, otherwise keystrokes would not be correctly setup
    for use for that Control.</p>

    <h2>Styling Controls</h2>

    <p>There are two methods for customizing the look of a Control. The most
    difficult and yet most flexible approach is to write a new Skin for the
    Control which precisely implements the visuals and behaviors which you
    desire for the Control. Consult the Skin documentation for more details.</p>

    <p>The easiest and yet very powerful method for styling the built in
    Controls is by using CSS. Please note that in this release the following
    CSS description applies only to the default Skins provided for the built
    in Controls. Subsequent releases will make this generally available for
    any custom third party Controls which desire to take advantage of these
    CSS capabilities.</p>

    <p>Each of the default Skins for the built in Controls is comprised of
    multiple individually styleable areas or regions. This is much like an
    HTML page which is made up of &lt;div&gt;&apos;s and then styled from
    CSS. Each individual region may be drawn with backgrounds, borders, images,
    padding, margins, and so on. The JavaFX CSS support includes the ability
    to have multiple backgrounds and borders, and to derive colors. These
    capabilities make it extremely easy to alter the look of Controls in
    JavaFX from CSS.</p>

    <p>The colors used for drawing the default Skins of the built in Controls
    are all derived from a base color, an accent color and a background
    color. Simply by modifying the base color for a Control you can alter the
    derived gradients and create Buttons or other Controls which visually fit
    in with the default Skins but visually stand out.</p>

    <pre><code>
    import javafx.scene.control.Button;

    Button {
        text: "JavaFX"
        style: "base: red"
    }
    </code></pre>

    <p>As with all other Nodes in the scenegraph, Controls can be styled by
    using an external stylesheet, or by specifying the style directly on the
    Control. Although for examples it is easier to express and understand by
    specifying the style directly on the Node, it is recommended to use an
    external stylesheet and use either the styleClass or id of the Control,
    just as you would use the "class" or id of an HTML element with HTML
    CSS.</p>

    <p>Each UI Control specifies a styleClass which may be used to
    style controls from an external stylesheet. For example, the Button
    control is given the "button" CSS style class. The CSS style class names
    are hyphen-separated lower case as opposed to camel case, otherwise, they
    are exactly the same. For example, Button is "button", RadioButton is
    "radio-button", Tooltip is "tooltip" and so on.</p>

    <p>If you wish to override an existing style in your stylesheet, you can
    do so simply by providing the rule you would like to use. For example, if
    you wanted all Buttons to be red by default, you could do the following:</p>

    <pre><code>
    .button {
        base: red;
    }
    </code></pre>

    <p>If you wish to take complete control of the look of a Control from CSS,
    then instead of overriding properties you may instead want to give your
    Control a different styleClass and provide unique styles for it in CSS.
    For example:</p>

    <pre><code>
    import javafx.scene.control.Button;

    Button {
        text: "JavaFX"
        styleClass: "my-button"
    }
    </code></pre>

    <pre><code>
    /* in css stylesheet */
    .my-button {
        background-color: red
    }
    </code></pre>

    <p>The class documentation for each Control defines the default Skin
    regions which can be styled. For further information regarding the CSS
    capabilities provided with JavaFX, see the
    <!-- TODO workaround for broken relative links from package docs -->
    <a href="javafx.scene/doc-files/cssref.html">CSS Reference Guide</a>.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.effect</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for attaching graphical filter effects to JavaFX Scene Graph Nodes.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for attaching graphical filter effects to JavaFX Scene Graph Nodes.</p>
<p>An effect is a graphical algorithm that produces an image, typically
   as a modification of a source image.
   An effect can be associated with a scene graph <code>Node</code> by setting the
   <a href="javafx.scene/javafx.scene.Node.html">effect</a>
   attribute.
   Some effects change the color properties of the source pixels
   (such as <a href="javafx.scene.effect/javafx.scene.effect.ColorAdjust.html">javafx.scene.effect.ColorAdjust</a>),
   others combine multiple images together (such as
   <a href="javafx.scene.effect/javafx.scene.effect.Blend.html">Blend</a>),
   while still others warp or move the pixels of the source image around (such as
   <a href="javafx.scene.effect/javafx.scene.effect.DisplacementMap.html">DisplacementMap</a> or <a href="javafx.scene.effect/javafx.scene.effect.PerspectiveTransform.html">PerspectiveTransform</a>).
   All effects have at least one input defined and the input can be set
   to another effect to chain the effects together and combine their
   results, or it can be left unspecified in which case the effect will
   operate on a graphical rendering of the node it is attached to.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.effect.light</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for light source implementations needed for the
<a href="javafx.scene.effect.light.Lighting Lighting">Lighting</a> effect.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for light source implementations needed for the
<a href="afx.scene.effect.light.Lighting Lighting">Lighting</a> effect.
</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.image</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for loading and displaying images.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for loading and displaying images.</p>
<ul>
    <li> The <a href="javafx.scene.image/javafx.scene.image.Image.html">javafx.scene.image.Image</a> class is used to load images
    (synchronously or asynchronously). Image can be resized as it is loaded and 
    the resizing can be performed with specified filtering quality and
    with an option of preserving image's original aspect ratio.

    <li> The <a href="javafx.scene.image/javafx.scene.image.ImageView.html">javafx.scene.image.ImageView</a> is a <code>Node</code> used
    for displaying images loaded with <code>Image</code> class.
    It allows displaying a dynamically scaled and/or cropped view of the source
    image. The scaling can be performed with specified filtering quality and
    with an option of preserving image's original aspect ratio.
</ul></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.input</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for mouse and keyboard input event handling.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for mouse and keyboard input event handling.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.layout</b></td><td class="description">
<p class="comment"><p>The JavaFX layout API provides a mechanism to establish the dynamic layout
     behavior of nodes in the scene graph.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>The JavaFX layout API provides a mechanism to establish the dynamic layout
     behavior of nodes in the scene graph.   While parts of an application's scene graph
     may have a static layout where the size and position of nodes is fixed, other
     parts will need to be laid out dynamically as the application executes.
     This is required in part because JavaFX is a cross-platform technology, which means that
     often the precise size of things (screen, fonts, etc) may vary across platforms
     and cannot be reliably determined until runtime.  The other driver is that
     modern interfaces are highly dynamic (rotating screens, variable content, etc),
     so it's impossible for most applications to predict the exact size and location
     of visual elements over time, especially if the user can resize the screen or
     nodes within it.</p>

    <p>Therefore, layout often requires that the size and position of nodes be
     defined relative to aspects of the scene graph (scene size, node bounds, etc),
     often resulting in a complex set of dependencies, particularly in a
     large scene.   These dependencies can be defined by using JavaFX's bind language
     feature, however, as the scene becomes complex, this approach becomes
     both unwieldy to program and inefficient to execute.   So, the scene graph
     also supports a procedural layout mechanism that enables branches of the
     scene graph to be marked as 'needing layout' so that such dirty branches will
     be laid out in a single top-down procedural layout pass on the next pulse,
     just prior to rendering. This approach allows layout changes to be coalesced
     and processed just once, avoiding unnecessary interim layout calculations.</p>

    <p>This layout mechanism is driven automatically by the scene graph once the
     application creates and displays a <a href="javafx.scene/javafx.scene.Scene.html">Scene</a>.  An
     application typically only needs to declare the scene graph structure using
     appropriate node classes and the scene graph invokes layout at appropriate times.
    </p>

<h3>Laying out a Scene</h3>

    <p>Applications create a scene graph by placing nodes in the <code>content</code>
        sequence of a <a href="javafx.scene/javafx.scene.Scene.html">Scene</a>.    The portion of the scene graph
        that will be visible to the user (the 'viewport') is defined by the scene's
        bounds: <code>0,0 width x height</code>.   By default the scene will not constrain
        the contents of the scene graph to fit within its bounds, so any nodes which
        extend beyond its bounds will simply be clipped.</p>

    <p>If an application wishes to constrain the contents of the scene graph to fit
        within the visual bounds of the scene, then it should use a container
        at the root of the scene and bind the container's <code>width/height</code>
        to the <code>width/height</code> of the scene:

    <pre><code>Stage {
    var scene:Scene;
    scene: scene = Scene {
        width: 500
        height: 400
        contents: Stack {
            width: bind scene.width
            height: bind scene.height
            content: [ ....]
        }
    }
}</code></pre>

        This will also ensure that for desktop applications, where the user may
        resize the stage/scene, that the contents will track those dynamic changes.
    </p>

    <p>For desktop applications, there are two ways to establish the initial
        size of a scene.  First, the application may set the scene's <code>width/height</code>
        variables directly, as in the above example.  Alternatively, the application
        may leave the scene's <code>width/height</code> uninitialized and allow the
        scene to compute its own initial size based on the preferred size of
        its content (e.g. 'packing' the scene around the content):

    <pre><code>Stage {
    var scene:Scene;
    scene: scene = Scene {
        // scene will 'shrink-to-fit' its content
        contents: Stack {
            width: bind scene.width
            height: bind scene.height
            content: [ ....]
        }
    }
}</code></pre>

        Note that for non-desktop applications (tv, mobile), the size of the
        stage/scene may be fixed by the device and not configurable by the application.
    </p>


<h3>Resizable vs. Non-Resizable Nodes</h3>

    <p>The scene graph supports both resizable and non-resizable nodes.  A resizable
    node is one which has a range of acceptable sizes (minimum, preferred, maximum) and
    its parent will resize it within that range during layout, given the parent's own layout
    policy and the layout needs of sibling nodes.  Applications should therefore <em>not</em>
    set the <code>width/height</code> of resizable nodes since parents will override those values
    during layout.  See <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a> for more details.
    Non-resizable nodes, on the other hand, do <em>not</em> have a consistent resizing API and so
    are <em>not</em> resized by their parents during layout; Applications must establish
    the size of non-resizable nodes by setting appropriate variables.</p>

     <table border="1">
        <thead><tr><th>Resizable Classes</th><th>Non-resizable Classes</th></tr></thead>
        <tbody><tr><td>Containers, Controls</td><td>Group, CustomNode, Shapes, Text, ImageView</td></tr></tbody>
    </table></p>
    <p>
    For example:
    <pre><code>    Button {
        // Resizable: do NOT set width/height, as parent will resize during layout
        text: "Apply"
    }
    Circle {
        // Non-resizable: must establish shape size by setting geometric variables
        radius: 50
        strokeWidth: 2
    }</code></pre>

    <p>Note: Be aware that <a href="javafx.scene.shape/javafx.scene.shape.Rectangle.html">Rectangle</a>'s
    <code>width/height</code> variables are not the same as Resizable's
    <code>width/height</code> variables, since for a Rectangle the width/height does <em>not</em> include its stroke,
    which is centered on its geometry, causing its bounds to extend outside its width/height values.</p>


<h3>Using Groups vs. Containers</h3>

    <p>Group and Container are both general-purpose <a href="javafx.scene/javafx.scene.Parent.html">Parent</a> classes,
    however each deals with layout differently.</p>

    <p><a href="javafx.scene/javafx.scene.Group.html">Group</a> is not Resizable and does not constrain its
    content in any way; it simply takes on the collective bounds of its children.
    Groups do not position their children, so applications must set the position
    of nodes inside a group.  If a group contains <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a> content,
    it will auto-size those nodes to their preferred sizes during layout, unless
    <code>autoSizeChildren</code> is false.  The following Group example creates a row of 10 circles:

<pre><code>Group {
    opacity: .5
    content: for (i in [0..9]) {
        def c = Circle {
            radius: 20
            // Must compute position
            layoutX: bind (i * 25) - c.layoutBounds.minX
            layoutY: bind 0 - c.layoutBounds.minY
        }
    }
}</code></pre>
</p>

<p><a href="javafx.scene.layout/javafx.scene.layout.Container.html">Container</a> classes are <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a> and
    are designed to perform layout on their children.   They will attempt to
    constrain their contents to fit within their width/height, although it's
    possible for their content to extend outside their bounds and the container
    will not clip it.  Containers will also layout children regardless of their
    visibility, so if an application doesn't want an invisible node to be factored into the
    container's layout, then it should unmanage it (described later).</p>

<p>To compare with the Group example above, let's instead use an HBox container to
    create the same row of circles:

<pre><code>HBox {
    spacing: 5
    content: for (i in [0..9]) {
        Circle {
            radius: 20
        }
    }
}</code></pre>

    <p>As the preceding example shows, it's much easier to use Container classes to
        achieve common layout patterns, so applications should utilize containers
        whenever possible and fall back to direct layout inside
       groups when containers won't suffice or the direct approach is sufficiently
       simple (e.g. static positioning or minimal bind requirements).</p>


    <p>If an application doesn't want a parent (Container, Group, etc) to manage the layout of
        a node at all, it can unmanage the node:

    <pre><code>Stack {
    content: [
        Rectangle {
            managed: false
        }
        ...other content...
     ]
}
</code></pre>

     Once a node is unmanaged, the application must take full responsibility to
     manage the size and position of the node, as its parent will completely
     ignore it in terms of layout.  See <a href="javafx.scene/javafx.scene.Node.html">Node.managed</a>
     for more details.</p>


<h3>Using Concrete Containers</h3>

    <p>The platform provides a handful of concrete Container classes for common layout idioms:

     <table border="1">
        <thead>
        <tr>
            <th>Container</th>
            <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.Stack.html">Stack</a></td>
            <td>Lays out nodes in a back-to-front layered stack with configurable alignment.</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.HBox.html">HBox</a></td>
            <td>Lays out nodes in single row with configurable spacing and alignment.</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.VBox.html">VBox</a></td>
            <td>Lays out nodes in single column with configurable spacing and alignment.</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.Tile.html">Tile</a></td>
            <td>Lays out nodes in uniformly sized "tiles", where tiles are either
                flowed horizontally in rows or vertically in columns.</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.Flow.html">Flow</a></td>
            <td>Lays out nodes in either a horizontal or vertical "flow", wrapping
                nodes at its width (for horizontal) or height (for vertical) boundaries.</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.Panel.html">Panel</a></td>
            <td>Enables layout customization using an object-literal (vs. Container subclass).</td>
        </tr>
        <tr>
            <td>
            <a href="javafx.scene.layout/javafx.scene.layout.ClipView.html">ClipView</a></td>
            <td>Lays out a single node in a view with a rectangular clip.</td>
        </tr>
        </tbody>
    </table>
    <p>
    Applications often need to nest different containers to achieve desired
    layout structure. For example, the following code creates a scene with an 8 pixel
    margin around the edges, a toolbar spanning the top, a tile of images in the center, and
    a status area at the bottom:
    </p>
<pre><code>Stage {
    title: "Nested Containers"
    var scene:Scene;
    scene: scene = Scene {
        content: VBox {
            width: bind scene.width
            height: bind scene.height
            padding: Insets { top: 8 right: 8 bottom: 8 left: 8 }
            content: [
                ToolBar { ... }
                Tile {
                    hgap: 6 vgap: 6
                    content: for (img in images)
                                 ImageView { image: img }
                }
                Label { text: "Status:" }
            ]
        }
    }
}</code></pre>


    <p>All of the concrete container classes do layout by assigning a "layout area" 
    to each child and then laying out the child within that area using the child's
    layout preferences for sizing and alignment.  If the child is <a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a>
    (Controls and Containers), the container will use its sizing preferences to
    compute its layout area and determine how to size it within that area.
    If the child is non-resizable (Shapes, Group, etc), the container will
    treat it as a rigid object and simply position it within its layout area.</p>
   
    <h4>Customizing Layout Preferences</h4>

    <p>All the concrete container classes support customizing layout preferences
        on a per-node basis by setting a <a href="javafx.scene.layout/javafx.scene.layout.LayoutInfo.html">LayoutInfo</a> on the node's
        layoutInfo variable.   The most common application usage of LayoutInfo is
        to override the preferred size of a resizable node:

    <pre><code>VBox {
    spacing: 8
    content: [
        Label { Text: "Friends" }
        ListView {
            layaoutInfo: LayoutInfo { width: 180 height: 150 }
        }
    ]
}</code></pre>

    

<h3>Understanding Layout Bounds</h3>

    <p><a href="javafx.scene/javafx.scene.Node.html">Node</a> defines a separate <code>layoutBounds</code> variable for the
        purpose of defining the 'logical' bounds of the node that should be used for layout
        calculations.  LayoutBounds does not necessarily correlate to the visual
        bounds of a node and it is computed differently depending on the node type:

     <table border="1">
         <thead>
             <tr>
                 <th>Node Type</th>
                 <th>Layout Bounds</th>
             </tr>
         </thead>
         <tbody>
             <tr>
                 <td><a href="javafx.scene.shape/javafx.scene.shape.Shape.html">Shape</a>,<a href="afx.scene.image.ImageView ImageView">ImageView</a></td>
                 <td>Includes geometric bounds (geometry plus stroke).<br>
                     Does NOT include effect, clip, or any transforms.
                 </td>
             </tr>
             <tr>
                 <td><a href="javafx.scene.text/javafx.scene.text.Text.html">Text</a></td>
                 <td>logical bounds based on the font height and content width, including white space.
                     can be configured to be tight bounds around chars glyphs by setting <code>boundsType</code>. <br>
                     Does NOT include effect, clip, or any transforms.
                 </td>
             </tr>
             <tr>
                 <td><a href="javafx.scene.layout/javafx.scene.layout.Resizable.html">Resizable</a> (All Containers & Controls)</td>
                 <td>always 0,0 width x height, regardless of visual bounds,
                     which might be larger or smaller than layout bounds.
                 </td>
             </tr>
             <tr>
                 <td><a href="javafx.scene/javafx.scene.Group.html">Group</a>,<a href="javafx.scene/javafx.scene.CustomNode.html">CustomNode</a></td>
                 <td>Union of all visible childrens' visual bounds (<code>boundsInParent</code>)<br>
                     Does NOT include effect, clip, or transforms set directly on group/customnode,
                     however DOES include effect, clip, transforms set on individual children (since
                     those are included in the child's <code>boundsInParent</code>).
                     CustomNode subclasses may override <code>layoutBounds</code>.
                 </td>
             </tr>
         </tbody>
     </table></p>
     <p>
    So for example, if a <a href="javafx.scene.effect/javafx.scene.effect.DropShadow.html">DropShadow</a> is added to a shape, that
    shadow will <em>not</em> be factored into the bounds of that shape for layout.  Or, if a
    <a href="afx.scene.animation.transition.ScaleTransition ScaleTransition">ScaleTransition</a> is used to pulse the
    size of a button, that pulse animation will not disturb layout around that button.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.media</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for integrating audio and video into JavaFX Applications.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for integrating audio and video into JavaFX Applications.
Currently, the primarily used for this package is media playback.
There are 3 essential classes in the Media Package:
<a href="javafx.scene.media/javafx.scene.media.Media.html">Media</a>, <a href="javafx.scene.media/javafx.scene.media.MediaPlayer.html">MediaPlayer</a>, and <a href="javafx.scene.media/javafx.scene.media.MediaView.html">MediaView</a>.
</p>
<p>
This is an example of a simple media player application:
<code><pre>
    import javafx.stage.Stage;
    import javafx.scene.Scene;
    import javafx.scene.media.Media;
    import javafx.scene.media.MediaPlayer;
    import javafx.scene.media.MediaView;


    Stage {
        scene: Scene {
            content: MediaView {
                mediaPlayer: MediaPlayer {
                    media: Media{ source:"file:///media/sample.fxm"}
                }
            }
        }
    }
</pre></code>
</p>
<p> The <code>Stage</code> contains a <code>Scene</code>, which contains a
<code>MediaView</code> object. The <code>MediaView</code>
object has a <code>MediaPlayer</code>, which is playing the <code>Media</code>
object.
</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.paint</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for colors and gradients used to fill shapes and
backgrounds when rendering the scene graph.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for colors and gradients used to fill shapes and
backgrounds when rendering the scene graph. </p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.shape</b></td><td class="description">
<p class="comment"><p>Provides the set of 2D classes for defining and performing operations on 
objects related to two-dimensional geometry.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of 2D classes for defining and performing operations on 
objects related to two-dimensional geometry.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.text</b></td><td class="description">
<p class="comment"><p>Provides the set of classes for fonts and renderable Text Node.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of classes for fonts and renderable Text Node.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.scene.transform</b></td><td class="description">
<p class="comment"><p>Provides the set of convenient classes to perform rotating, scaling,
shearing, and translation transformations for <code>Affine</code> objects.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the set of convenient classes to perform rotating, scaling,
shearing, and translation transformations for <code>Affine</code> objects.</p></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.stage</b></td><td class="description">
<p class="comment"><p>Provides the top-level container classes for JavaFX scripts.</p>
<a href="#" class="long-desc-open"><img src="images/JFX_arrow_right.png"></a>
<div class="long-desc">
<p class="comment"><p>Provides the top-level container classes for JavaFX scripts.</p>
<p>This package encapsulates the JavaFX graphical script surroundings for the
Stage - Scene metaphor, with different capabilites available
to the Stage depending on the underlying semantics of the runtime
container.</p>
<p>The JavaFX <font size="1"><sup>TM</sup></font> Stage interface provides
interfaces and classes for the environment and presentation of JavaFX
script instantiations. The stage presentation specifics for each
JavaFX runtime platform will allow a script to be presented on different
platforms with consistent functionality across each runtime.<br>
</p>
<p>The main areas of functionality of <code>javafx.stage</code>
package include </p>
<ol>
  <li>
    <p><b>Stage:</b> Stages are the graphical container for
JavaFX script instantiations. Stages are the attributed drawing surface
for the JavaFX script.</p>
  </li>
  <li>
    <p><b>StageExtension:</b> Each Stage may have one or more StageExtension
    instances set to provide additional functionality for the script.  A StageExtension will
    only be utilized if the script is running within the profile specific to that StageExtension</p>
  </li>
  <li>
    <p><b>AppletStageExtension:</b> When a JavaFX script is running within a browser, 
    the <code>AppletStageExtension</code> is enabled to manage the drag transition from a browser
    to the desktop.  Dragging a Stage out of a browser is supported in the Java <font size="1"><sup>TM</sup></font> 
    plugin versions 6u10 and later.
    </p>
  </li>
  <li>
    <p><b>StageStyle:</b> The <code>StageStyle</code> specifies the decoration and visibility semantics
    of the <code>Stage</code>.
    </p>
  </li>
</ol></p>
                                                &nbsp;
                                            </div>
</td>
</tr>
<tr>
<td class="name"><b>javafx.util</b></td><td class="description"></td>
</tr>
</table>
</div>
</body>
</html>
